<html lang="en">

    <head>
        <title>Addrman</title>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <style type="text/css">
            div#tooltip {
                position: absolute;
                display: inline-block;
                padding: 10px;
                background: white;
                pointer-events: none;
                opacity: 0;
                z-index: 1;
            }
        </style>
    </head>
    <body>
        <h1>Addrman</h1>
        <div id="debug">
            <p><em>Connecting...</em></p>
        </div>
        <label>
            mouse-over highlight
            <select name="highlight" id="highlight">
                <option value="no-highlight">no highlight</option>
                <option value="same-source">same source</option>
                <option value="same-address-subnet">same address subnet</option>
                <option value="same-source-subnet">same address subnet</option>
                <option value="same-address">same address</option>
                <option value="same-port">same port</option>
            </select>
        </label>
        <div style="position: relative;">
            <canvas id="canvas-highlight"></canvas>
            <canvas id="canvas"></canvas>
        </div>
        <div id="tooltip"></div>
        <script>
        const uri = 'wss://' + location.host + "/" + location.pathname + '/addrman';
        const ws = new WebSocket(uri);

        const NUM_NEW_BUCKETS = 1024
        const NUM_TRIED_BUCKETS = 256
        const NUM_ADDR_PER_BUCKET = 64

        const NUM_ADDR_PER_ADDR_COLUMN = 8

        const ADDR_PIXEL_SIZE = 2
        const ADDR_PIXEL_PADDING = 1
        const ADDR_PIXEL_SIZE_AND_PADDING = ADDR_PIXEL_SIZE + ADDR_PIXEL_PADDING

        const BUCKET_PIXEL_PADDING = 2
        const BUCKET_PIXEL_SIZE = NUM_ADDR_PER_ADDR_COLUMN * ADDR_PIXEL_SIZE_AND_PADDING + BUCKET_PIXEL_PADDING

        const NEW_BUCKETS_PER_BUCKET_COLUMN = 32
        const TRIED_BUCKETS_PER_BUCKET_COLUMN = 16

        height = BUCKET_PIXEL_SIZE * NEW_BUCKETS_PER_BUCKET_COLUMN;
        width = height;

        function address_network_type(addrinfo) {
            if (addrinfo.addr.includes("onion")) {
                return "tor"
            } else if (addrinfo.addr.includes("internal")) {
                return "internal"
            } else if (addrinfo.addr.includes("i2p")) {
                return "i2p"
            } else if (addrinfo.addr.includes("[")) {
                return "ipv6"
            } else if (addrinfo.addr.split(".").length == 4) {
                return "ipv4"
            }
            return "unknown"
        }

        function port(addrinfo) {
            return addrinfo.addr.split(":").slice(-1)
        }

        function preprocess(addrinfo) {
            addrinfo.port = port(addrinfo)
            addrinfo.net_type = address_network_type(addrinfo)
            return addrinfo
        }

        network_to_color = {
            "ipv4": d3.schemeDark2[0],
            "ipv6": d3.schemeDark2[1],
            "tor": d3.schemeDark2[2],
            "i2p": d3.schemeDark2[3],
            "interal": d3.schemeDark2[4],
            "unknown": d3.schemeDark2[5],
        }

        function calc_addr_x_y(bucket, bucket_pos) {
            let bucket_x = (bucket % NEW_BUCKETS_PER_BUCKET_COLUMN) * BUCKET_PIXEL_SIZE
            let bucket_pos_x = ADDR_PIXEL_SIZE_AND_PADDING * (bucket_pos % NUM_ADDR_PER_ADDR_COLUMN)
            let x = bucket_x + bucket_pos_x;
            let bucket_y = Math.floor(bucket / NEW_BUCKETS_PER_BUCKET_COLUMN) * BUCKET_PIXEL_SIZE
            let y = bucket_y + ADDR_PIXEL_SIZE_AND_PADDING * Math.floor(bucket_pos / NUM_ADDR_PER_ADDR_COLUMN);
            return [x, y];
        }

        let redrawTimeout;
        let newTable = new Array(1024*64);
        let newTableAddrPositions = new Array(1024*64);

        for (const i of newTable.keys()) {
            let bucket = Math.floor(i / NUM_ADDR_PER_BUCKET);
            let bucket_pos = i % NUM_ADDR_PER_BUCKET
            let [x, y] = calc_addr_x_y(bucket, bucket_pos)
            newTableAddrPositions[i] = [x, y];
        }

        let tree = d3.quadtree()
            .x(d => newTableAddrPositions[d.bucket * NUM_ADDR_PER_BUCKET + d.bucket_pos][0])
            .y(d => newTableAddrPositions[d.bucket * NUM_ADDR_PER_BUCKET + d.bucket_pos][1])
            .extent([[0,0], [width*1.1, height*1.1]])

        ws.onopen = function() {
            debug.innerHTML = '<p><em>Connected!</em></p>';
        };
        ws.onmessage = function(msg) {
            let addrInfo = JSON.parse(msg.data);
            newTable[addrInfo.bucket * 64 + addrInfo.bucket_pos] = addrInfo;
            tree.add(preprocess(addrInfo))
            // we wait 20ms before drawing incase we receive another msg
            // this avoids redrawing too frequently
            clearTimeout(redrawTimeout);
            redrawTimeout = setTimeout(draw, 20);
        };
        ws.onclose = function() {
            debug.getElementsByTagName('em')[0].innerText = 'Disconnected!';
        };

        // The main canvas for drawing buckets and addresses
        var canvas = d3.select('#canvas')
        canvas
            .attr('width', width)
            .attr('height', height)
            .style("position", "absolute")
            .style("left", "0")
            .style("top", "0")
            .style('z-layer:', '99')
            .style('border', 'solid 1px gray');
        var context = canvas.node().getContext('2d');

        // A highlight canvas for drawing mouse-over highlights
        var canvasHighlight = d3.select('#canvas-highlight')
        canvasHighlight
            .attr('width', width)
            .attr('height', height)
            .style("left", "0")
            .style("top", "0")
            .style("position", "absolute")
            .style('border', 'solid 1px red');
        var contextHighlight = canvasHighlight.node().getContext('2d');

        // Zoom and pan state
        var currentZoom = d3.zoomIdentity;

        const highlightSelect = d3.select("#highlight")
        const tooltip = d3.select('#tooltip')
        const zoomContext = d3.zoom()
            .scaleExtent([1, 16])
            .translateExtent([[0, 0], [width, height]])
            .on("zoom", ({transform}) => {
                currentZoom = transform;
                draw(true);
            })
            .on("end", ({transform}) => {draw()})

        // zooming on the highlight canvas as it sits above the main canvas
        d3.select(context.canvas).call(zoomContext);

        // mouse over on the highlight canvas as it sits above the main canvas
        d3.select(context.canvas).on('mousemove', e => {
            x = (e.clientX - e.target.getBoundingClientRect().left - currentZoom.x) / currentZoom.k
            y = (e.clientY - e.target.getBoundingClientRect().top - currentZoom.y) / currentZoom.k

            addrinfo = tree.find(x-(ADDR_PIXEL_SIZE/2), y-(ADDR_PIXEL_SIZE/2), 2)
            if (addrinfo){
                tooltip
                    .style('top', e.clientY + 5 + 'px')
                    .style('left', e.clientX + 5 + 'px')
                    .html(formatTooltip(addrinfo));
                tooltip.transition()
                    .delay(100)
                    .duration(10)
                    .style("opacity", 1);
                draw_background(addrinfo)
            } else {
                tooltip.style('opacity', 0);
            }
        });

        function draw_highlight(addrInfo) {
            let addrToHighlight = []
            switch (highlightSelect.node().value) {
                case "same-source":
                    addrToHighlight = newTable.filter(Boolean).filter(a => a.source == addrInfo.source)
                    break;
                case "same-addr-subnet":
                    addrToHighlight = newTable.filter(Boolean).filter(a => a.addr_subnet == addrInfo.addr_subnet)
                    break;
                case "same-src-subnet":
                    addrToHighlight = newTable.filter(Boolean).filter(a => a.source_subnet == addrInfo.source_subnet)
                    break;
                case "same-port":
                    addrToHighlight = newTable.filter(Boolean).filter(a => a.port == addrInfo.port)
                    break;
                case "same-address":
                    addrToHighlight = newTable.filter(Boolean).filter(a => a.addr == addrInfo.addr)
                    break;
                default:
            }

            if (addrToHighlight.length > 0) {
                for (const addrInfo of addrToHighlight) {
                    let [x, y] = newTableAddrPositions[addrInfo.bucket * NUM_ADDR_PER_BUCKET + addrInfo.bucket_pos ]
                    contextHighlight.strokeStyle = "black"
                    contextHighlight.lineWidth = 1;
                    contextHighlight.strokeRect(x, y, ADDR_PIXEL_SIZE, ADDR_PIXEL_SIZE);
                }
            }
        }

        function draw_background(highlight, zoom) {
            transform = currentZoom;
            contextHighlight.save();
            contextHighlight.clearRect(0, 0, width, height);
            contextHighlight.translate(transform.x, transform.y);
            contextHighlight.scale(transform.k, transform.k);
            contextHighlight.beginPath();
            for(position = 0; position < NUM_NEW_BUCKETS; position++) {
                let [x, y] = newTableAddrPositions[position*NUM_ADDR_PER_BUCKET]
                contextHighlight.fillStyle = "#eee"
                contextHighlight.fillRect(x-0.5, y-0.5, BUCKET_PIXEL_SIZE-BUCKET_PIXEL_PADDING, BUCKET_PIXEL_SIZE-BUCKET_PIXEL_PADDING);
                if (zoom && transform.k > 4) {
                    contextHighlight.fillStyle = "black"
                    contextHighlight.font = "2px sans-serif";
                    contextHighlight.fillText("bucket " + position, x, y+1.5);
                }
            }
            if (highlight) {
                draw_highlight(highlight);
            }
            contextHighlight.fill();
            contextHighlight.restore();
        }

        function draw(zoom) {
            d3.select('#tooltip').style('opacity', 0);
            d3.select("#debug").text(newTable.filter(Boolean).length + " addresses drawn");
            transform = currentZoom;
            context.save();
            context.clearRect(0, 0, width, height);
            context.translate(transform.x, transform.y);
            context.scale(transform.k, transform.k);
            context.beginPath();

            draw_background(undefined, zoom);

            if (!zoom) {
                position = 0
                for (const addrInfo of newTable) {
                    let [x, y] = newTableAddrPositions[position]
                    if (addrInfo === undefined) {
                        if (transform.k > 3) {
                            context.strokeStyle = "gray"
                            context.lineWidth = 0.1;
                            context.strokeRect(x, y, ADDR_PIXEL_SIZE, ADDR_PIXEL_SIZE);
                        }
                    } else {
                        /*
                        if (port(addrInfo) == 8333) {
                            context.fillStyle = "red"
                        } else {
                            context.fillStyle = "blue"
                        }
                        */
                        context.fillStyle = network_to_color[address_network_type(addrInfo)]
                        context.fillRect(x, y, ADDR_PIXEL_SIZE, ADDR_PIXEL_SIZE); // x, y, width and height
                    }
                    position++;
                }
            }
            context.fill();
            context.restore();
        }

        function formatTooltip(addrinfo) {
            return `
            <table>
                <tr><td>address</td><td>${addrinfo.addr}</td></tr>
                <tr><td>addr subnet</td><td>${addrinfo.addr_subnet}</td></tr>
                <tr><td>network</td><td>${addrinfo.net_type}</td></tr>
                <tr><td>source</td><td>${addrinfo.source}</td></tr>
                <tr><td>src subnet</td><td>${addrinfo.source_subnet}</td></tr>
                <tr><td>bucket</td><td>${addrinfo.bucket}</td></tr>
                <tr><td>position</td><td>${addrinfo.bucket_pos}</td></tr>
            </table>`
        }

        draw();
        </script>
    </body>
</html>
