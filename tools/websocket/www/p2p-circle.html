<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bootstrap demo</title>
  </head>
  <body>
    <div id="websocket-picker"></div>
    <div id="plot"></div>
  </body>

  <script src="js/d3@7.js"></script>
  <script src="js/plot@0.6.js"></script>
  <script src="js/websocket-picker.js"></script>
  <script type="module">
    const width = 800;
    const height = 720;

    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");

    let g_nodes = new Map();
    let g_links = [];
    let g_msgs = [];

    function hslhash(input) {
      let hash = input.hashCode();
      // h 0 - 360
      let h = hash % 360;
      // s 70% - 100%
      let s = (hash % 30) + 70;
      // l 65% - 90%
      let l = (hash % 25) + 65;
      return `hsl(${h} ${s}% ${l}%)`;
    }

    String.prototype.hashCode = function () {
      let hash = 0,
        i,
        chr;
      if (this.length === 0) return hash;
      for (i = 0; i < this.length; i++) {
        chr = this.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
      }
      return hash;
    }

    const simulation = d3
      .forceSimulation(Array.from(g_nodes.values()))
      .force("link", d3.forceLink(g_links))
      .force("charge", d3.forceManyBody().strength(-200))
      .force("center", d3.forceCenter(width / 2, height / 2).strength(0.1))
      .force("radial", d3.forceRadial(600, width / 2, height / 2).strength(1))
      .alpha(1)
      .alphaDecay(0.0)
      .velocityDecay(0.5)
      .restart();

    function update() {
      context.clearRect(0, 0, width, height);
      context.font = "10px monospace";
      context.fillStyle = "black";

      simulation.nodes(Array.from(g_nodes.values()));
      let linksToRemove = [];
      let nodesToRemove = [];
      g_links.forEach((link) => {
        context.fillText(link.msg, ((link.source.x - link.target.x) / 1.3) + width / 2, ((link.source.y - link.target.y) / 1.3) + height / 2);
        context.beginPath();
        context.moveTo(link.source.x, link.source.y);
        context.lineTo(link.target.x, link.target.y);
        context.strokeStyle = link.color;
        context.stroke();
        if (link.closeTime !== undefined && Date.now() - link.closeTime > 1000) {
          linksToRemove.push(link.peer_id);
        }
      });
      g_links.map((l) => {
        l.msgshowcounter+= 1;
        if (l.msgshowcounter > 10) {
          l.msg = "";
          l.color = "ligthgray";
        }
        return l;
      })


      g_nodes.values().forEach((node) => {
        context.globalAlpha = node.closeTime ? 0.2 : 1;
        context.beginPath();
        context.arc(node.x, node.y, node.id == "we" ? 20 : 10, 0, 2 * Math.PI);
        context.fillStyle = node.color;
        context.strokeStyle = "gray";
        context.fill();
        context.stroke();
        if (node.closeTime !== undefined && Date.now() - node.closeTime > 10000) {
          nodesToRemove.push(node.id);
        }
        context.globalAlpha = 1; // reset
      });

      removeLinks(linksToRemove);
      removeNodes(nodesToRemove);
      simulation.force(
        "link",
          d3.forceLink(g_links).id((d) => d.id)
        );
        let tmpnodes = Array.from(g_nodes.values());
        //tmpnodes.sort((a,b) => (a.addr > b.addr) ? 1 : ((b.addr > a.addr) ? -1 : 0))
        simulation.nodes(tmpnodes);
      }

      simulation.on("tick", update);

      function removeNodes(ids) {
        for (const id of ids) {
          g_nodes.delete(id);
        }
      }

      function removeLinks(ids) {
        for (const id of ids) {
          g_links = g_links.filter((l) => l.peer_id !== id);
        }
      }

      function addNodeAndLink(peer_id, addr, inbound) {
        let node = {
          id: peer_id,
          x: width / 2,
          y: height / 2,
          addr: addr,
          color: hslhash(addr.split(":")[0].split(".").slice(0,2).join(".")),
          closeTime: undefined
        };
        g_nodes.set(peer_id, node);
        let link = {
          source: inbound ? peer_id : "we",
          target: inbound ? "we" : peer_id,
          peer_id: peer_id,
          color: "#999",
          msg: "",
          msgshowcounter: 99,
        };
        g_links.push(link);
        simulation.nodes(Array.from(g_nodes.values()));
        simulation.alpha(0.1);
      }


      function handleWebsocketMessage(event) {
        const m = JSON.parse(event.data);

        if (m.hasOwnProperty("Conn")) {
          // Handle connection events
          if (m.Conn.event.hasOwnProperty("Closed")) {
            let id = m.Conn.event.Closed.conn.peer_id;
            if (g_nodes.has(id)) {
              let node = g_nodes.get(id);
              node.color = "gray";
              node.closeTime = Date.now();
              g_nodes.set(id, node);
            }
            g_links = g_links.map((l) => {
              if (l.peer_id === id) {
                l.closeTime = Date.now();
              }
              return l;
            });
          } else if (m.Conn.event.hasOwnProperty("InboundEvicted")) {
            // skip, already handled in "Closed"
            return;
          } else if (m.Conn.event.hasOwnProperty("Inbound")) {
            let event = m.Conn.event.Inbound.conn;
            addNodeAndLink(event.peer_id, event.addr, event.inbound);
          } else {
            console.log(m.Conn);
          }
        } else if (m.hasOwnProperty("Msg")) {
          // Handle P2P msg events
          let meta = m.Msg.meta;
          if (!g_nodes.has(meta.peer_id)) {
            addNodeAndLink(meta.peer_id, meta.addr, true);
          }
          g_links.map((l) => {
            if (l.peer_id === meta.peer_id) {
              l.msg = meta.inbound ? "<-" + meta.command : "->" + meta.command;
              l.msgshowcounter = 0;
            }
            return l
          })
        }
      }

    const div = document.querySelector("#plot");
    div.append(canvas);

    function handleWebsocketReset() {
      g_nodes = new Map();
      g_links = []
      g_msgs = []
      
      const we = { id: "we", color: "white", addr: "", fx: width / 2, fy: height / 2 };
      g_nodes.set(we.id, we);
    }

    window.onload = (event) => {
      initWebsocketPicker("websockets.json", "websocket-picker", handleWebsocketMessage, handleWebsocketReset)
    };

  </script>
</html>
